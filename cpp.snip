snippet     cmd
abbr        snippet commands {{{
    // assign avl ncm dijkstra geo2 kruskal graph uf lca BIT
    // matrix dinic next_combination topcoder lcm vi st gin
#}}}

snippet     tmp
abbr        Comp-Prog template Code {{{
    #include <bits/stdc++.h>
    
    using namespace std;
    
    #define INF 1001000100010001000
    #define MOD 1000000007
    #define EPS 1e-10
    #define int long long
    #define rep(i, N) for (int i = 0; i < N; i++)
    #define Rep(i, N) for (int i = 1; i < N; i++)
    #define For(i, a, b) for (int i = (a); i < (b); i++)
    #define pb push_back
    #define eb emplace_back
    #define mp make_pair
    #define i_i pair<int, int>
    #define vi vector<int>
    #define vvi vector<vi >
    #define vb vector<bool>
    #define vvb vector<vb >
    #define vp vector< i_i >
    #define all(a) (a).begin(), (a).end()
    #define Int(x) int x; cin >> x;
    #define int2(x, y) Int(x); Int(y);
    #define int3(x, y, z) Int(x); int2(y, z);
    #define fir first
    #define sec second
    #define ffir first.first
    #define fsec first.second
    #define sfir second.first
    #define ssec second.second
    #define Decimal fixed << setprecision(10)
     
    //int dxy[5] = {0, 1, 0, -1, 0};
    // cmd${0:#:TARGET}
    
    signed main()
    {
        std::ios::sync_with_stdio(false);
        std::cin.tie(0);
    
        return 0;
    }
#}}}

snippet     topcoder
abbr        template for topcoder {{{
    #include <bits/stdc++.h>

    using namespace std;

    #define INF 1010001000
    #define MOD 1000000007
    #define ll long long
    #define rep(i, N) for (int i = 0; i < N; i++)
    #define Rep(i, N) for (int i = 1; i < N; i++)
    #define pb push_back
    #define eb emplece_back
    #define mp make_pair
    #define i_i pair<int, int>
    #define vi vector<int>
    #define vvi vector<vi >
    #define vb vector<bool>
    #define vvb vector<vb >
    #define vp vector< i_i >
    #define all(a) (a).begin(), (a).end()
    #define Int(x) int x; scanf("%d", &x);
    #define int2(x, y) int x, y; scanf("%d %d", &x, &y);
    #define int3(x, y, z) int2(x, y) Int(z)
    #define fir first
    #define sec second
    #define ffir fir.fir
    #define fsec fir.sec
    #define sfir sec.fir
    #define ssec sec.sec
    #define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile("mov %%rsp, %%rbx\nmov %%rax, %%rsp":"=b"(stack_extend_origin_memory_):"a"((char*)stack_extend_memory_+(size)-1024));

    #define END_STACK_EXTEND asm volatile("mov %%rax, %%rsp"::"a"(stack_extend_origin_memory_));free(stack_extend_memory_);

    //int dxy[5] = {0, 1, 0, -1, 0};
    // assign avl ncm dijkstra geo2 kruskal graph uf lca BIT
    // matrix dinic next_combination topcoder lcm
    // stack size = 128 * 1024 * 1024


    class 
    { 
        public:




    };



    int main()
    {

        return 0;
    }
#}}}

snippet     ncm
abbr        nCm mod p {{{
    int fact[1145140];
    int pascal_table[100][100];

    /*
     * tableをdoubleにしてncmの割合も求められる
     * 1/2して下ってゆくように書き換えてその場で作る.
     */
    void make_pascal(int mod)
    {
        rep(i, 100) {
            pascal_table[i][0] = 1;
            for (int j = 1; j < i; j++) {
                pascal_table[i][j] = (pascal_table[i-1][j-1] +
                    pascal_table[i-1][j]) % mod;
            }
            pascal_table[i][i] = 1;
        }
    }

    int gcd(int a, int b) { if (b == 0) return a; return gcd(b, a%b); }

    int extgcd(int a, int b, int &x, int &y)
    {
        int d = a;
        if (b != 0) {
            d = extgcd(b, a % b, y, x);
            y -= (a / b) * x;
        } else { x = 1; y = 0; }
        return d;
    }

    int repow(int x, int n, int mod)
    {
        if (n == 0) return 1;
        int res = repow(x * x % mod, n / 2, mod);
        if (n & 1) res = res * x % mod;
        return res;
    }
    
    int mod_inverse(int a, int m)
    {
        int x, y;
        extgcd(a, m, x, y);
        return ( m + x % m ) % m;
    }
    
    int table(int n)
    {
        int sum = 1;
        fact[0] = 1;
        Rep(i, n+2) {
            sum *= i;
            sum %= MOD;
            fact[i] = sum;
        }
    }
    
    int mod_fact(int n, int p, int &e)
    {
        e = 0;
        if (n == 0) return 1;
        int res = mod_fact(n / p, p, e);
        e += n / p;
    
        if (n / p % 2 != 0) return res * (p - fact[n % p]) % p;
        return res * fact[n % p] % p;
    }
    
    /*
     * 必ずtable()を呼んでから使う.
     * n = 1001000くらいで
     */
    int mod_comb(int n, int k, int p) {
        if (n < 0 || k < 0 || n < k) return 0;
        int e1, e2, e3;
        int a1 = mod_fact(n, p, e1), a2 = mod_fact(k, p, e2), a3 = mod_fact(n-k, p, e3);
        if (e1 > e2 + e3) return 0;
        return a1 * mod_inverse(a2 * a3 % p, p) % p;
    }
    
    int ncm(int n, int r)
    {
        if (r == 0) return 1;
        return (n-r+1) * ncm(n, r-1) / r;
    }
#}}}

snippet     BIT
abbr        BinaryIndexedTree {{{
    template< class T >
    struct BinaryIndexedTree
    {
        vector< T > data;
    
        BinaryIndexedTree(int sz)
        {
            data.assign(++sz, 0);
        }
    
        T sum(int k)
        {
            T ret = 0;
            for(++k; k > 0; k -= k & -k) ret += data[k];
            return (ret);
        }
    
        void add(int k, T x)
        {
            for(++k; k < data.size(); k += k & -k) data[k] += x;
        }
    };
#}}}

snippet     avl
abbr        AVL_Tree binarysearch {{{
    template <class T>
    struct avl_tree {
        struct node {
            T key;
            int size, height;
            node *child[2];
            node(const T &key) : key(key), size(1), height(1) {
                child[0] = child[1] = 0; }
        } *root;
        typedef node *pointer;
        avl_tree() { root = NULL; }
    
        // keyと一致する要素が発見されればその参照を、
        // されなければNullを返す
        pointer find(const T &key) { return find(root, key); }
        node *find(node *t, const T &key) {
            if (t == NULL) return NULL;
            if (key == t->key) return t;
            else if (key < t->key) return find(t->child[0], key);
            else                   return find(t->child[1], key);
        }
        // 要素の挿入
        void insert(const T &key) { root = insert(root, new node(key)); }
        node *insert(node *t, node *x) {
            if (t == NULL) return x;
            if (x->key <= t->key) t->child[0] = insert(t->child[0], x);
            else                  t->child[1] = insert(t->child[1], x);
            t->size += 1;
            return balance(t);
        }
        // 要素の削除
        void erase(const T &key) { root = erase(root, key); }
        node *erase(node *t, const T &x) {
            if (t == NULL) return NULL;
            if (x == t->key) {
                return move_down(t->child[0], t->child[1]);
            } else {
                if (x < t->key) t->child[0] = erase(t->child[0], x);
                else            t->child[1] = erase(t->child[1], x);
                t->size -= 1;
                return balance(t);
            }
        }
        node *move_down(node *t, node *rhs) {
            if (t == NULL) return rhs;
            t->child[1] = move_down(t->child[1], rhs);
            return balance(t);
        }
    #define sz(t) (t ? t->size : 0)
    #define ht(t) (t ? t->height : 0)
        node *rotate(node *t, int l, int r) {
            node *s = t->child[r];
            t->child[r] = s->child[l];
            s->child[l] = balance(t);
            if (t) t->size = sz(t->child[0]) + sz(t->child[1]) + 1;
            if (s) s->size = sz(s->child[0]) + sz(s->child[1]) + 1;
            return balance(s);
        }
        node *balance(node *t) {
            for (int i = 0; i < 2; ++i) {
                if (ht(t->child[!i]) - ht(t->child[i]) < -1) {
                    if (ht(t->child[i]->child[!i]) - ht(t->child[i]->child[i]) > 0)
                        t->child[i] = rotate(t->child[i], i, !i);
                    return rotate(t, !i, i);
                }
            }
            if (t) t->height = max(ht(t->child[0]), ht(t->child[1])) + 1;
            if (t) t->size = sz(t->child[0]) + sz(t->child[1]) + 1;
            return t;
        }
        // 小さい順にk番目の要素がどんなkeyを持つのかを調べる
        /*
         * 要素数を保持しておいて、木内でi番目の要素が
         * 何なのかが分かるのを利用して二分探索をするとか。
                int a = 目的の値
                int st = -1, ed = tree.size(), mid;        //xxxooo, (st, ed]
                while (ed - st >= 2) {
                    mid = (st + ed) / 2;
                    if ((tree.rank(mid))->key >= a) ed = mid;
                    else st = mid;
                }
                cout << sz - ed << endl;
         */
        pointer rank(int k) const { return rank(root, k); }
        pointer rank(node *t, int k) const {
            if (!t) return NULL;
            int m = sz(t->child[0]);
            if (k  < m) return rank(t->child[0], k);
            if (k == m) return t;
            if (k  > m) return rank(t->child[1], k - m - 1);
        }
    };
#}}}

snippet     dijkstra
abbr        dijkstra {{{
    //単一始点最短経路(負閉路なし)
    //Dijkstra O((|E|+|V|)log|V|)
    //dist: 始点から各頂点までの最短距離
    //戻り値: 最短経路木の親頂点(根は-1)
    vector<int> dijkstra(const Graph &g, int s, Array &dist) {
        int n = g.size();
        assert(s < n);
        enum { WHITE, GRAY, BLACK };
        vector<int> color(n, WHITE); color[s] = GRAY;
        vector<int> prev(n, -1);
        dist.assign(n, INF); dist[s] = 0;
        using State = tuple<Weight, int, int>; //始点からの最短距離 子 親
        priority_queue<State, vector<State>, greater<State>> pq; pq.emplace(0, s, -1);
        while (pq.size()) {
            Weight d; int v, u; tie(d, v, u) = pq.top(); pq.pop();
            if (dist[v] < d)continue;
            color[v] = BLACK; prev[v] = u;
            for (auto &e : g[v]) {
                if (color[e.d] == BLACK)continue;
                if (dist[e.d] > dist[v] + e.w) {
                    dist[e.d] = dist[v] + e.w;
                    pq.emplace(dist[e.d], e.d, v);
                    color[e.d] = GRAY;
                }
            }
        }
        return prev;
    }
#}}}

snippet     geo2
abbr        2DGeometry Library {{{
    //#define double long double
    const double EPS = 1e-8;
    const double PI = acos(-1);
    #define equals(a,b) (fabs((a)-(b)) < EPS)
    #define next(P,i) P[(i+1)%P.size()]
    #define prev(P,i) P[(i+P.size()-1)%P.size()]

    struct Point {
        double x, y;
        Point() {}
        Point(double x, double y) :x(x), y(y) {}

        Point &operator+=(const Point &p) { x += p.x; y += p.y; return *this; }
        Point &operator-=(const Point &p) { x -= p.x; y -= p.y; return *this; }
        Point &operator*=(double a) { x *= a; y *= a; return *this; }
        Point &operator/=(double a) { x /= a; y /= a; return *this; }

        double abs() { return sqrt(norm()); }
        double norm() { return x*x + y*y; }
    };
    Point operator+(const Point &p1, const Point &p2) { return Point(p1) += p2; }
    Point operator-(const Point &p1, const Point &p2) { return Point(p1) -= p2; }
    Point operator*(const Point &p, double a) { return Point(p) *= a; }
    Point operator/(const Point &p, double a) { return Point(p) /= a; }
    bool operator==(const Point &p1, const Point &p2) { return equals(p1.x, p2.x) && equals(p1.y, p2.y); }
    bool operator<(const Point &p1, const Point &p2) {
        //return p1.y != p2.y ? p1.y < p2.y : p1.x < p2.x; //y昇順 -> x昇順
        return p1.x != p2.x ? p1.x < p2.x : p1.y < p2.y; //x昇順 -> y昇順
    }
    bool operator>(const Point &p1, const Point &p2) { return p2 < p1; }
    inline istream &operator >> (istream &is, Point &p) { double x, y; is >> x >> y; p = Point(x, y); return is; }
    inline ostream &operator << (ostream &os, const Point &p) { os << p.x << ' ' << p.y; return os; }

    struct Vector :public Point {
        using Point::Point;
        Vector() {}
        Vector(const Point &P) { x = P.x; y = P.y; }
        Vector rotate(double rad) { return Vector(x*cos(rad) - y*sin(rad), x*sin(rad) + y*cos(rad)); }
        Vector unit() { return *this / abs(); }
    };

    //内積 dot product
    double dot(Vector a, Vector b) { return a.x*b.x + a.y*b.y; }
    //外積 cross product の大きさ（正負あり）
    double cross(Vector a, Vector b) { return a.x*b.y - a.y*b.x; }

    struct Line {
        Point p1, p2;
        Line() {}
        Line(Point p1, Point p2) :p1(p1), p2(p2) {}
    };

    struct Segment :public Line {
        using Line::Line;
        Segment() {}
        Segment(const Line &L) { p1 = L.p1; p2 = L.p2; }
        Vector vec() { return p2 - p1; }
    };

    struct Circle {
        Point c; //center
        double r; //radius
        Circle() {}
        Circle(Point c, double r) :c(c), r(r) {}
    };
    using Polygon = vector<Point>;

    //degree to radian
    double rad(double deg) { return PI*deg / 180; }
    //radian to degree
    double deg(double rad) { return rad / PI * 180; }

    //偏角 argument
    double arg(Vector p) { return atan2(p.y, p.x); }

    //極形式 polar form
    Vector polar(double r, double a) { return Point(cos(a)*r, sin(a)*r); }

    //2つのベクトルの角度
    double angle(Vector a, Vector b) {
        double lena = a.abs(), lenb = b.abs();
        if (lena == 0 || lenb == 0)return 0; //解なし
        double costheta = dot(a, b) / (lena*lenb);
        if (equals(costheta, 1))costheta = 1; //誤差対策
        return acos(costheta);
    }

    bool inrange(Point p, double x1, double y1, double x2, double y2) {
        return x1 <= p.x&&p.x <= x2&&y1 <= p.y&&p.y <= y2;
    }

    //直交判定
    bool is_orthogonal(Vector a, Vector b) { return equals(dot(a, b), 0.0); }
    bool is_orthogonal(Segment s1, Segment s2) { return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0); }

    //平行判定
    bool is_parallel(Vector a, Vector b) { return equals(cross(a, b), 0.0); }
    bool is_parallel(Segment s1, Segment s2) { return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0); }

    //射影
    Point project(Segment s, Point p) {
        Vector base = s.p2 - s.p1;
        double r = dot(p - s.p1, base) / base.norm();
        return s.p1 + base*r;
    }
    //反射
    Point reflect(Segment s, Point p) { return p + (project(s, p) - p)*2.0; }

    //線分(p0,p1)に対するp2の位置関係
    enum { ONLINE_FRONT = -2, CLOCKWISE, ON_SEGMENT, COUNTER_CLOCKWISE, ONLINE_BACK };
    int ccw(Point p0, Point p1, Point p2) {
        Vector a = p1 - p0, b = p2 - p0;
        if (cross(a, b) > EPS)return COUNTER_CLOCKWISE;
        if (cross(a, b) < -EPS)return CLOCKWISE;
        if (dot(a, b) < -EPS)return ONLINE_BACK; //p2 p0 p1
        if (a.norm() < b.norm())return ONLINE_FRONT; //p0 p1 p2
        return ON_SEGMENT;
    }
    int ccw(Vector a, Vector b) {
        if (cross(a, b) > EPS)return COUNTER_CLOCKWISE;
        if (cross(a, b) < -EPS)return CLOCKWISE;
        if (dot(a, b) < -EPS)return ONLINE_BACK; //p2 p0 p1
        if (a.norm() < b.norm())return ONLINE_FRONT; //p0 p1 p2
        return ON_SEGMENT;
    }

    //直線と直線の交差判定
    bool intersect(Segment a, Segment b) {
        Point p1 = a.p1, p2 = a.p2, p3 = b.p1, p4 = b.p2;
        return (ccw(p1, p2, p3)*ccw(p1, p2, p4) <= 0 &&
            ccw(p3, p4, p1)*ccw(p3, p4, p2) <= 0);
    }
    //(交差判定続く)

    //2点間の距離
    double get_distance(Point a, Point b) { return (a - b).abs(); }

    //直線と点の距離
    double get_distance(Line l, Point p) { return abs(cross(l.p2 - l.p1, p - l.p1) / (l.p2 - l.p1).abs()); }

    //線分と点の距離
    double get_distance(Segment s, Point p) {
        if (dot(s.p2 - s.p1, p - s.p1) < 0.0)return (p - s.p1).abs();
        if (dot(s.p1 - s.p2, p - s.p2) < 0.0)return (p - s.p2).abs();
        return get_distance(Line(s), p);
    }

    //線分と線分の距離
    double get_distance(Segment s1, Segment s2) {
        if (intersect(s1, s2))return 0.0;
        return	min(
            min(get_distance(s1, s2.p1), get_distance(s1, s2.p2)),
            min(get_distance(s2, s1.p1), get_distance(s2, s1.p2))
        );
    }

    //円と直線の交差判定
    bool intersect(Circle c, Line l) { return get_distance(l, c.c) <= c.r + EPS; }

    //円と円の交差判定 共通接線の数
    int intersect(Circle c1, Circle c2) {
        double d = get_distance(c1.c, c2.c);
        if (d > c1.r + c2.r)return 4;
        if (d == c1.r + c2.r)return 3;
        if (d + c1.r == c2.r || d + c2.r == c1.r)return 1;
        if (d + c1.r < c2.r || d + c2.r < c1.r)return 0;
        return 2;
    }

    //線分と線分の交点
    Point get_cross_point(Segment a, Segment b) {
        assert(intersect(a, b));
        Vector base = b.p2 - b.p1;
        double area1 = abs(cross(base, a.p1 - b.p1));
        double area2 = abs(cross(base, a.p2 - b.p1));
        double t = area1 / (area1 + area2);
        return a.p1 + (a.p2 - a.p1)*t;
    }

    //円と直線の交点
    pair<Point, Point> get_cross_points(Circle c, Line l) {
        assert(intersect(c, l));
        Vector pr = project(l, c.c);
        Vector e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();
        double base = sqrt(c.r*c.r - (pr - c.c).norm());
        return make_pair(pr + e*base, pr - e*base);
    }

    //円と円の交点
    pair<Point, Point> get_cross_points(Circle c1, Circle c2) {
        int m = intersect(c1, c2);
        assert(m != 4 && m != 0);
        double d = (c1.c - c2.c).abs();
        double a = acos((c1.r*c1.r - c2.r*c2.r + d*d) / (2 * c1.r*d));
        double t = arg(c2.c - c1.c);
        return make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));
    }

    //点の内包
    enum { OUT = 0, ON, IN };
    int contains(const Polygon &pl, Point p) {
        int n = pl.size();
        bool x = false;
        for (int i = 0; i < n; i++) {
            Point a = pl[i] - p, b = pl[(i + 1) % n] - p;
            if (abs(cross(a, b)) < EPS&&dot(a, b) < EPS)return ON;
            if (a.y > b.y)swap(a, b);
            if (a.y < EPS&&EPS<b.y&&cross(a, b)>EPS)x = !x;
        }
        return (x ? IN : OUT);
    }

    int contains(Circle c, Point p) {
        double d = get_distance(c.c, p);
        if (equals(d, c.r))return ON;
        if (d < c.r)return IN;
        return OUT;
    }

    //多角形の面積
    double area(const Polygon &p) {
        double a = 0;
        for (size_t i = 0; i < p.size(); i++)
            a += cross(p[i], p[(i + 1) % p.size()]);
        return fabs(a / 2.0);
    }

    //凸性判定（反時計回り）
    bool is_convex(Polygon g) {
        for (size_t i = 0; i < g.size(); i++)
            if (ccw(g[i], g[(i + 1) % g.size()], g[(i + 2) % g.size()]) == CLOCKWISE)
                return false;
        return true;
    }

    //凸包
    //Graham scan https://en.wikipedia.org/wiki/Graham_scan
    //辺上の点を含めない
    Polygon convex_hull(Polygon P) {
        sort(P.begin(), P.end());
        Polygon up;
        for (Point &p : P) {
            while (up.size() > 1 && ccw(up[up.size() - 2], up[up.size() - 1], p) != CLOCKWISE)up.pop_back();
            up.emplace_back(p);
        }
        Polygon down;
        for (Point &p : P) {
            while (down.size() > 1 && ccw(down[down.size() - 2], down[down.size() - 1], p) != COUNTER_CLOCKWISE)down.pop_back();
            down.emplace_back(p);
        }
        reverse(up.begin(), up.end()); //反時計回りに
        down.insert(down.end(), up.begin() + 1, up.end() - 1);
        return down;
    }

    //凸包
    //Graham scan https://en.wikipedia.org/wiki/Graham_scan
    //辺上の点を含む
    Polygon convex_hull_with_points_online(Polygon P) {
        sort(P.begin(), P.end());
        Polygon up;
        for (Point &p : P) {
            int _ccw;
            while (up.size() > 1 && (_ccw = ccw(up[up.size() - 2], up[up.size() - 1], p)) != CLOCKWISE &&_ccw != ONLINE_FRONT)
                up.pop_back();
            up.emplace_back(p);
        }
        Polygon down;
        for (Point &p : P) {
            int _ccw;
            while (down.size() > 1 && (_ccw = ccw(down[down.size() - 2], down[down.size() - 1], p)) != COUNTER_CLOCKWISE && _ccw != ONLINE_FRONT)
                down.pop_back();
            down.emplace_back(p);
        }
        reverse(up.begin(), up.end()); //反時計回りに
        down.insert(down.end(), up.begin() + 1, up.end() - 1);
        return down;
    }

    //凸多角形の最遠頂点対間距離
    //calipers https://en.wikipedia.org/wiki/Rotating_calipers
    double diameter(Polygon P) {
        P = convex_hull(P);
        auto mima = minmax_element(P.begin(), P.end());
        int I = mima.first - P.begin();
        int J = mima.second - P.begin();
        double maxd = get_distance(P[I], P[J]);

        int maxi, maxj, i, j;
        i = maxi = I;
        j = maxj = J;
        do {
            if (ccw(next(P, i) - P[i], next(P, j) - P[j]) == COUNTER_CLOCKWISE)
                j = (j + 1) % P.size();
            else
                i = (i + 1) % P.size();
            if (maxd < get_distance(P[i], P[j])) {
                maxd = get_distance(P[i], P[j]);
                maxi = i, maxj = j;
            }
        } while (!(i == I&&j == J));
        return maxd;
    }

    //多角形を(0,0)を中心として回転
    Polygon rotate(const Polygon &P, double rad) {
        Polygon ret;
        for (auto &p : P)
            ret.emplace_back(p.x*cos(rad) - p.y*sin(rad), p.x*sin(rad) + p.y*cos(rad));
        return ret;
    }

    //Heron's formula
    double area(double a, double b, double c) {
        double s = (a + b + c) / 2;
        return sqrt(s*(s - a)*(s - b)*(s - c));
    }

    //多角形の重心
    Point center(const Polygon &P) {
        Point ret(0, 0);
        for (auto &p : P)ret = ret + p;
        ret = ret / P.size();
        return ret;
    }

    //垂直二等分線
    Line get_bisection(const Point &p1, const Point &p2) {
        Circle c1(p1, INF), c2(p2, INF); //INF だと誤差が酷い
        auto ps = get_cross_points(c1, c2);
        return Line(ps.first, ps.second);
    }

    //3点から距離が等しい点 (3点を円周上に持つ円の中心)
    Point get_center(const Point &p1, const Point &p2, const Point &p3) {
        Line l1 = get_bisection(p1, p2), l2 = get_bisection(p2, p3);
        return get_cross_point(l1, l2);
    }

    //点pを通る円cの接線における接点
    pair<Point, Point> get_tangent(const Circle &c, const Point &p) {
        double d = get_distance(c.c, p);
        Circle c2((c.c + p) / 2, d / 2);
        return get_cross_points(c, c2);
    }
#}}}

snippet     uf
abbr        union-find tree {{{
    struct UnionFind {
        vector<int> parent;
        int size;
        UnionFind(int n) :parent(n, -1), size(n) {}
        bool unite(int x, int y) {
            x = root(x); y = root(y);
            if (x == y)return false;
            if (sizeOf(x) < sizeOf(y))swap(x, y);
            parent[x] += parent[y]; parent[y] = x; size--;
            return true;
        }
        bool same(int x, int y) { return root(x) == root(y); }
        int root(int x) { return parent[x] < 0 ? x : parent[x] = root(parent[x]); }
        int sizeOf(int x) { return -parent[root(x)]; }
    };
#}}}

snippet     graph
abbr        for graph theory {{{
    using Weight = int;
    using Flow = int;
    struct Edge {
        int s, d; Weight w; Flow c;
        Edge() {};
        Edge(int s, int d, Weight w = 1) : s(s), d(d), w(w), c(w) {};
    };
    bool operator<(const Edge &e1, const Edge &e2) { return e1.w < e2.w; }
    bool operator>(const Edge &e1, const Edge &e2) { return e2 < e1; }
    inline ostream &operator<<(ostream &os, const Edge &e) { return (os << '(' << e.s << ", " << e.d << ", " << e.w << ')'); }
    
    using Edges = vector<Edge>;
    using Graph = vector<Edges>;
    using Array = vector<Weight>;
    using Matrix = vector<Array>;
    
    void addArc(Graph &g, int s, int d, Weight w = 1) {
        g[s].emplace_back(s, d, w);
    }
    void addEdge(Graph &g, int a, int b, Weight w = 1) {
        addArc(g, a, b, w);
    addArc(g, b, a, w);
    }
#}}}

snippet     kruskal
abbr        minimum spaning tree {{{
    //最小全域木 (Minimum Spanning Tree)
    //Kruskal O(|E|log|E|)
    //非連結グラフでは最小全域森
    // ** 要include uf, graph ** 
    pair<Weight, Edges> kruskal(const Graph &g) {
        int n = g.size();
        UnionFind uf(n);
        Edges es;
        for (int i = 0; i < n; i++)
            for (int j = 0; j < g[i].size(); j++) {
                Edge e = g[i][j];
            //for (auto &e : g[i])
                es.push_back(e);
            }
        sort(es.begin(), es.end());
        Weight total = 0;
        Edges mst;
        for (int i = 0; i < es.size(); i++) {
            Edge e = es[i];
        //for (auto &e : es)
            if (!uf.same(e.s, e.d)) {
                uf.unite(e.s, e.d);
                mst.push_back(e);
                total += e.w;
            }
        }
        return make_pair(total, mst);
    }
#}}}

snippet     lca
abbr        Lowest Common Ancestor {{{
    //lowest common ancestor (ダブリング + dfs再帰)
    //構築O(NlogN) クエリO(logN)
    struct LowestCommonAncestor {
        const int n, log2_n;
        vector< vector <int> > parent;
        vector<int> depth;
        const Graph &g;
        LowestCommonAncestor(const Graph &g, int root)
            :g(g), n(g.size()), log2_n(log2(n) + 1), parent(log2_n, vector<int>(n)), depth(n) {
            dfs(root, -1, 0);
            for (int k = 0; k + 1 < log2_n; k++) {
                for (int v = 0; v < n; v++) {
                    if (parent[k][v] < 0)
                        parent[k + 1][v] = -1;
                    else
                        parent[k + 1][v] = parent[k][parent[k][v]];
                }
            }
        }
        void dfs(int s, int p, int d) {
            parent[0][s] = p;
            depth[s] = d;
            for (int i = 0; i < g[s].size(); i++) {
                Edge e = g[s][i];
                if (e.d == p)continue;
                dfs(e.d, s, d + 1);
            }
        }
        int get(int u, int v) {
            if (depth[u] > depth[v]) swap(u, v);
            for (int k = 0; k < log2_n; k++) {
                if ((depth[v] - depth[u]) >> k & 1) {
                    v = parent[k][v];
                }
            }
            if (u == v) return u;
            for (int k = log2_n - 1; k >= 0; k--) {
                if (parent[k][u] != parent[k][v]) {
                    u = parent[k][u];
                    v = parent[k][v];
                }
            }
            return parent[0][u];
        }
        int dist(int u, int v) {
            int w = get(u, v);
            return depth[u] + depth[v] - depth[w] * 2;
        }
    };
#}}}

snippet     matrix
abbr        matrix power {{{
    /*
     * 結合法則、分配法則、可換(+)、単位元0, 1を持つ和積を備える(半環)
     */
    using Num = unsigned long long;
    struct Matrix {
        vector< vector< Num > > v, w;
        Matrix() {}
        Matrix(int n, int m) :v(n, vector<Num>(m)) { }
        inline int height()const { return (int)v.size(); }
        inline int width()const { return (int)v[0].size(); }
        inline Num& at(int i, int j) { return v[i][j]; }
        inline const Num& at(int i, int j)const { return v[i][j]; }
        static Matrix identity(int n) {
            Matrix A(n, n);
            for (int i = 0; i < n; i++) A.at(i, i) = 1;
            return A;
        }
        inline static Matrix identity(const Matrix& A) { return identity(A.height()); }
        Matrix &operator*=(const Matrix& B) {
            int n = height(), m = B.width(), p = B.height();
            assert(p == width());
            w.assign(n, vector<Num>(m, 0));
            for (int i = 0; i < n; i++)for (int j = 0; j < m; j++) {
                Num x = 0;
                for (int k = 0; k < p; k++)
                    x += at(i, k) * B.at(k, j);
                w[i][j] = x;
            }
            v.swap(w);
            return *this;
        }
    };
    Matrix operator^(const Matrix &m, long long exponent) {
        Matrix A = m, B = Matrix::identity(m);
        while (exponent) {
            if (exponent & 1) B *= A;
            A *= A;
            exponent >>= 1;
        }
        return B;
    }
#}}}

snippet     dinic
abbr        Max flow dinic {{{
    /* 
     * 必ずgraphも一緒にincludeすること
     */
    struct Dinic {
        int n, s, t;
        vector<int> level, prog, que;
        vector< vector< Flow > > cap, flow;
        vector< vector < int > > g;
        Flow inf;
        Dinic(const Graph &graph)
            : n(graph.size()),
            cap(n, vector<Flow>(n)),
            flow(n, vector<Flow>(n)),
            g(n, vector<int>()),
            inf(numeric_limits<Flow>::max() / 8) {
                for (int i = 0; i < n; i++) {
                    for (int j = 0; j < graph[i].size(); j++) {
                        Edge e = graph[i][j];
                        int u = e.s, v = e.d;
                        Flow c = e.c;
                        cap[u][v] += c;
                        cap[v][u] += c;
                        flow[v][u] += c;
                        g[u].push_back(v);
                        g[v].push_back(u);
                    }
                }
            }
        inline Flow residue(int u, int v) { return cap[u][v] - flow[u][v]; }
        Flow solve(int s_, int t_) {
            this->t = t_, this->s = s_;
            que.resize(n + 1);
            Flow res = 0;
            while (levelize()) {
                prog.assign(n, 0);
                res += augment(s, inf);
            }
            return res;
        }
        bool levelize() {
            int l = 0, r = 0;
            level.assign(n, -1);
            level[s] = 0;
            que[r++] = s;
            while (l != r) {
                int v = que[l++];
                if (v == t) break;
                for (int i = 0; i < g[v].size(); i++) {
                    int d = g[v][i];
                    if (level[d] == -1 && residue(v, d) != 0) {
                        level[d] = level[v] + 1;
                        que[r++] = d;
                    }
                }
            }
            return level[t] != -1;
        }
        Flow augment(int v, Flow lim) {
            Flow res = 0;
            if (v == t) return lim;
            for (int &i = prog[v]; i < (int)g[v].size(); i++) {
                const int &d = g[v][i];
                if (residue(v, d) == 0 || level[v] >= level[d]) continue;
                const Flow aug = augment(d, min(lim, residue(v, d)));
                flow[v][d] += aug;
                flow[d][v] -= aug;
                res += aug;
                lim -= aug;
                if (lim == 0) break;
            }
            return res;
        }
    };
#}}}
 
snippet     next_combination
abbr        next_combination {{{
    bool next_combination(std::vector<int>& v, int n) {
        int k = v.size();
        int p = k - 1;
        if (v[p] >= n) return false;
        while (p >= 0 && ++v[p] >= n - (k - p - 1)) --p;
        if (p < 0) return false;
        ++p;
        while (p < k) {
            v[p] = v[p - 1] + 1;
            ++p;
        }
        return true;
    }
#}}}

snippet     lcm
abbr        gcd, lcm {{{
    //最大公約数
    int gcd(int x, int y) { return y ? gcd(y, x%y) : x; }
    //最小公倍数
    int lcm(int x, int y) { return x / gcd(x, y) * y; }
    //最大公約数 複数個
    int gcd(const vector<int> &v) {
        int ret = v[0];
        for (int i = 1; i < v.size(); i++)
            ret = gcd(ret, v[i]);
        return ret;
    }
    //最小公倍数 複数個
    int lcm(const vector<int> &v) {
        int ret = v[0];
        for (int i = 1; i < v.size(); i++)
            ret = lcm(ret, v[i]);
        return ret;
    }
#}}}

snippet     vi
#{{{
options     head
abbr        vector input
    vector<${1:int}> ${2:data}(${3:n});
    for (int i = 0; i < $3; i++) {
        cin >> $2[i];
    }
    ${0:#:TARGET}
#}}}

snippet     st
#{{{
options     head
abbr        string input
    string ${1:st};
    cin >> $1;
    ${0:#:TARGET}
#}}}

snippet     gin
#{{{
options     head
abbr        graph input
    Graph ${1:g}(${2:n});
    for (int i = 0; i < $2; i++) {
        int tmpx, tmpy${3: };
       ${4: }tmpx--; tmpy--;
        addEdge($1, tmpx, tmpy$3);
    }
    ${0:#:TARGET}
#}}}

snippet     segtree
#{{{
options     head
abbr        segment tree
    struct Monoid {
        using T = int;
        T operator()(const T &a, const T& b) { return min(a, b); }
        static const T I = INT_MAX;
    };
    struct SegmentTree {
        using T = Monoid::T;
        Monoid op;
        int n;
        vector<T> d;
        SegmentTree(int m) {
            for (n = 1; n < m; n *= 2);
            d.assign(2 * n - 1, op.I);
        }
        void update(int k, T x) {
            k += n - 1;
            d[k] = x;
            while (k > 0) {
                k = (k - 1) / 2;
                d[k] = op(d[2 * k + 1], d[2 * k + 2]);
            }
        }
        T query(int a, int b, int k, int l, int r) {
            if (r <= a || b <= l)return op.I;
            if (a <= l&&r <= b)return d[k];
            int xl = query(a, b, 2 * k + 1, l, (l + r) / 2);
            int xr = query(a, b, 2 * k + 2, (l + r) / 2, r);
            return op(xl, xr);
        }
        T query(int a, int b) {
            return query(a, b, 0, 0, n);
        }
    };
#}}}

